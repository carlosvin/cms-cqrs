// Generated by the gRPC protobuf plugin.
// If you make any local change, they will be lost.
// source: cms.proto
#ifndef GRPC_cms_2eproto__INCLUDED
#define GRPC_cms_2eproto__INCLUDED

#include "cms.pb.h"

#include <grpc++/impl/internal_stub.h>
#include <grpc++/impl/rpc_method.h>
#include <grpc++/impl/service_type.h>
#include <grpc++/status.h>

namespace grpc {
class CompletionQueue;
class ChannelInterface;
class RpcService;
class ServerContext;
template <class OutMessage> class ClientAsyncResponseReader;
template <class OutMessage> class ServerAsyncResponseWriter;
}  // namespace grpc

namespace cms {

class CmsQuery GRPC_FINAL {
 public:
  class Stub GRPC_FINAL : public ::grpc::InternalStub {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status get(::grpc::ClientContext* context, const ::cms::Uuid& request, ::cms::Content* response);
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cms::Content>> Asyncget(::grpc::ClientContext* context, const ::cms::Uuid& request, ::grpc::CompletionQueue* cq, void* tag);
    ::grpc::Status get_all(::grpc::ClientContext* context, const ::cms::Query& request, ::cms::ContentList* response);
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cms::ContentList>> Asyncget_all(::grpc::ClientContext* context, const ::cms::Query& request, ::grpc::CompletionQueue* cq, void* tag);
   private:
    const ::grpc::RpcMethod rpcmethod_get_;
    const ::grpc::RpcMethod rpcmethod_get_all_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);

  class Service : public ::grpc::SynchronousService {
   public:
    Service() : service_(nullptr) {}
    virtual ~Service();
    virtual ::grpc::Status get(::grpc::ServerContext* context, const ::cms::Uuid* request, ::cms::Content* response);
    virtual ::grpc::Status get_all(::grpc::ServerContext* context, const ::cms::Query* request, ::cms::ContentList* response);
    ::grpc::RpcService* service() GRPC_OVERRIDE GRPC_FINAL;
   private:
    ::grpc::RpcService* service_;
  };
  class AsyncService GRPC_FINAL : public ::grpc::AsynchronousService {
   public:
    explicit AsyncService(::grpc::CompletionQueue* cq);
    ~AsyncService() {};
    void Requestget(::grpc::ServerContext* context, ::cms::Uuid* request, ::grpc::ServerAsyncResponseWriter< ::cms::Content>* response, ::grpc::CompletionQueue* cq, void *tag);
    void Requestget_all(::grpc::ServerContext* context, ::cms::Query* request, ::grpc::ServerAsyncResponseWriter< ::cms::ContentList>* response, ::grpc::CompletionQueue* cq, void *tag);
  };
};

class ContentCmdHandler GRPC_FINAL {
 public:
  class Stub GRPC_FINAL : public ::grpc::InternalStub {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status create(::grpc::ClientContext* context, const ::cms::Content& request, ::cms::CmdResponse* response);
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cms::CmdResponse>> Asynccreate(::grpc::ClientContext* context, const ::cms::Content& request, ::grpc::CompletionQueue* cq, void* tag);
   private:
    const ::grpc::RpcMethod rpcmethod_create_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);

  class Service : public ::grpc::SynchronousService {
   public:
    Service() : service_(nullptr) {}
    virtual ~Service();
    virtual ::grpc::Status create(::grpc::ServerContext* context, const ::cms::Content* request, ::cms::CmdResponse* response);
    ::grpc::RpcService* service() GRPC_OVERRIDE GRPC_FINAL;
   private:
    ::grpc::RpcService* service_;
  };
  class AsyncService GRPC_FINAL : public ::grpc::AsynchronousService {
   public:
    explicit AsyncService(::grpc::CompletionQueue* cq);
    ~AsyncService() {};
    void Requestcreate(::grpc::ServerContext* context, ::cms::Content* request, ::grpc::ServerAsyncResponseWriter< ::cms::CmdResponse>* response, ::grpc::CompletionQueue* cq, void *tag);
  };
};

class EventListenerEndpoint GRPC_FINAL {
 public:
  class Stub GRPC_FINAL : public ::grpc::InternalStub {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status on(::grpc::ClientContext* context, const ::cms::Event& request, ::cms::CmdResponse* response);
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cms::CmdResponse>> Asyncon(::grpc::ClientContext* context, const ::cms::Event& request, ::grpc::CompletionQueue* cq, void* tag);
   private:
    const ::grpc::RpcMethod rpcmethod_on_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);

  class Service : public ::grpc::SynchronousService {
   public:
    Service() : service_(nullptr) {}
    virtual ~Service();
    virtual ::grpc::Status on(::grpc::ServerContext* context, const ::cms::Event* request, ::cms::CmdResponse* response);
    ::grpc::RpcService* service() GRPC_OVERRIDE GRPC_FINAL;
   private:
    ::grpc::RpcService* service_;
  };
  class AsyncService GRPC_FINAL : public ::grpc::AsynchronousService {
   public:
    explicit AsyncService(::grpc::CompletionQueue* cq);
    ~AsyncService() {};
    void Requeston(::grpc::ServerContext* context, ::cms::Event* request, ::grpc::ServerAsyncResponseWriter< ::cms::CmdResponse>* response, ::grpc::CompletionQueue* cq, void *tag);
  };
};

class EventSource GRPC_FINAL {
 public:
  class Stub GRPC_FINAL : public ::grpc::InternalStub {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status apply(::grpc::ClientContext* context, const ::cms::Event& request, ::cms::CmdResponse* response);
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cms::CmdResponse>> Asyncapply(::grpc::ClientContext* context, const ::cms::Event& request, ::grpc::CompletionQueue* cq, void* tag);
    ::grpc::Status subscribe(::grpc::ClientContext* context, const ::cms::EventListener& request, ::cms::CmdResponse* response);
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cms::CmdResponse>> Asyncsubscribe(::grpc::ClientContext* context, const ::cms::EventListener& request, ::grpc::CompletionQueue* cq, void* tag);
    ::grpc::Status unsubscribe(::grpc::ClientContext* context, const ::cms::EventListener& request, ::cms::CmdResponse* response);
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cms::CmdResponse>> Asyncunsubscribe(::grpc::ClientContext* context, const ::cms::EventListener& request, ::grpc::CompletionQueue* cq, void* tag);
   private:
    const ::grpc::RpcMethod rpcmethod_apply_;
    const ::grpc::RpcMethod rpcmethod_subscribe_;
    const ::grpc::RpcMethod rpcmethod_unsubscribe_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);

  class Service : public ::grpc::SynchronousService {
   public:
    Service() : service_(nullptr) {}
    virtual ~Service();
    virtual ::grpc::Status apply(::grpc::ServerContext* context, const ::cms::Event* request, ::cms::CmdResponse* response);
    virtual ::grpc::Status subscribe(::grpc::ServerContext* context, const ::cms::EventListener* request, ::cms::CmdResponse* response);
    virtual ::grpc::Status unsubscribe(::grpc::ServerContext* context, const ::cms::EventListener* request, ::cms::CmdResponse* response);
    ::grpc::RpcService* service() GRPC_OVERRIDE GRPC_FINAL;
   private:
    ::grpc::RpcService* service_;
  };
  class AsyncService GRPC_FINAL : public ::grpc::AsynchronousService {
   public:
    explicit AsyncService(::grpc::CompletionQueue* cq);
    ~AsyncService() {};
    void Requestapply(::grpc::ServerContext* context, ::cms::Event* request, ::grpc::ServerAsyncResponseWriter< ::cms::CmdResponse>* response, ::grpc::CompletionQueue* cq, void *tag);
    void Requestsubscribe(::grpc::ServerContext* context, ::cms::EventListener* request, ::grpc::ServerAsyncResponseWriter< ::cms::CmdResponse>* response, ::grpc::CompletionQueue* cq, void *tag);
    void Requestunsubscribe(::grpc::ServerContext* context, ::cms::EventListener* request, ::grpc::ServerAsyncResponseWriter< ::cms::CmdResponse>* response, ::grpc::CompletionQueue* cq, void *tag);
  };
};

class AggregateRepository GRPC_FINAL {
 public:
  class Stub GRPC_FINAL : public ::grpc::InternalStub {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status get(::grpc::ClientContext* context, const ::cms::Uuid& request, ::cms::Aggregate* response);
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cms::Aggregate>> Asyncget(::grpc::ClientContext* context, const ::cms::Uuid& request, ::grpc::CompletionQueue* cq, void* tag);
    ::grpc::Status set(::grpc::ClientContext* context, const ::cms::Aggregate& request, ::cms::CmdResponse* response);
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cms::CmdResponse>> Asyncset(::grpc::ClientContext* context, const ::cms::Aggregate& request, ::grpc::CompletionQueue* cq, void* tag);
   private:
    const ::grpc::RpcMethod rpcmethod_get_;
    const ::grpc::RpcMethod rpcmethod_set_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);

  class Service : public ::grpc::SynchronousService {
   public:
    Service() : service_(nullptr) {}
    virtual ~Service();
    virtual ::grpc::Status get(::grpc::ServerContext* context, const ::cms::Uuid* request, ::cms::Aggregate* response);
    virtual ::grpc::Status set(::grpc::ServerContext* context, const ::cms::Aggregate* request, ::cms::CmdResponse* response);
    ::grpc::RpcService* service() GRPC_OVERRIDE GRPC_FINAL;
   private:
    ::grpc::RpcService* service_;
  };
  class AsyncService GRPC_FINAL : public ::grpc::AsynchronousService {
   public:
    explicit AsyncService(::grpc::CompletionQueue* cq);
    ~AsyncService() {};
    void Requestget(::grpc::ServerContext* context, ::cms::Uuid* request, ::grpc::ServerAsyncResponseWriter< ::cms::Aggregate>* response, ::grpc::CompletionQueue* cq, void *tag);
    void Requestset(::grpc::ServerContext* context, ::cms::Aggregate* request, ::grpc::ServerAsyncResponseWriter< ::cms::CmdResponse>* response, ::grpc::CompletionQueue* cq, void *tag);
  };
};

}  // namespace cms


#endif  // GRPC_cms_2eproto__INCLUDED

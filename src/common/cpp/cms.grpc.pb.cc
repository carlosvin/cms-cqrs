// Generated by the gRPC protobuf plugin.
// If you make any local change, they will be lost.
// source: cms.proto

#include "cms.pb.h"
#include "cms.grpc.pb.h"

#include <grpc++/async_unary_call.h>
#include <grpc++/channel_interface.h>
#include <grpc++/impl/client_unary_call.h>
#include <grpc++/impl/rpc_service_method.h>
#include <grpc++/impl/service_type.h>
#include <grpc++/stream.h>
namespace cms {

static const char* CmsQuery_method_names[] = {
  "/cms.CmsQuery/get",
  "/cms.CmsQuery/get_all",
};

std::unique_ptr< CmsQuery::Stub> CmsQuery::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel) {
  std::unique_ptr< CmsQuery::Stub> stub(new CmsQuery::Stub(channel));
  return stub;
}

CmsQuery::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : ::grpc::InternalStub(channel), rpcmethod_get_(CmsQuery_method_names[0], ::grpc::RpcMethod::NORMAL_RPC, channel->RegisterMethod(CmsQuery_method_names[0]))
  , rpcmethod_get_all_(CmsQuery_method_names[1], ::grpc::RpcMethod::NORMAL_RPC, channel->RegisterMethod(CmsQuery_method_names[1]))
  {}

::grpc::Status CmsQuery::Stub::get(::grpc::ClientContext* context, const ::cms::Uuid& request, ::cms::Content* response) {
  return ::grpc::BlockingUnaryCall(channel(), rpcmethod_get_, context, request, response);
}

std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cms::Content>> CmsQuery::Stub::Asyncget(::grpc::ClientContext* context, const ::cms::Uuid& request, ::grpc::CompletionQueue* cq, void* tag) {
  return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cms::Content>>(new ::grpc::ClientAsyncResponseReader< ::cms::Content>(channel(), cq, rpcmethod_get_, context, request, tag));
}

::grpc::Status CmsQuery::Stub::get_all(::grpc::ClientContext* context, const ::cms::Query& request, ::cms::ContentList* response) {
  return ::grpc::BlockingUnaryCall(channel(), rpcmethod_get_all_, context, request, response);
}

std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cms::ContentList>> CmsQuery::Stub::Asyncget_all(::grpc::ClientContext* context, const ::cms::Query& request, ::grpc::CompletionQueue* cq, void* tag) {
  return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cms::ContentList>>(new ::grpc::ClientAsyncResponseReader< ::cms::ContentList>(channel(), cq, rpcmethod_get_all_, context, request, tag));
}

CmsQuery::AsyncService::AsyncService(::grpc::CompletionQueue* cq) : ::grpc::AsynchronousService(cq, CmsQuery_method_names, 2) {}

CmsQuery::Service::~Service() {
  delete service_;
}

::grpc::Status CmsQuery::Service::get(::grpc::ServerContext* context, const ::cms::Uuid* request, ::cms::Content* response) {
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED);
}

void CmsQuery::AsyncService::Requestget(::grpc::ServerContext* context, ::cms::Uuid* request, ::grpc::ServerAsyncResponseWriter< ::cms::Content>* response, ::grpc::CompletionQueue* cq, void* tag) {
  AsynchronousService::RequestAsyncUnary(0, context, request, response, cq, tag);
}

::grpc::Status CmsQuery::Service::get_all(::grpc::ServerContext* context, const ::cms::Query* request, ::cms::ContentList* response) {
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED);
}

void CmsQuery::AsyncService::Requestget_all(::grpc::ServerContext* context, ::cms::Query* request, ::grpc::ServerAsyncResponseWriter< ::cms::ContentList>* response, ::grpc::CompletionQueue* cq, void* tag) {
  AsynchronousService::RequestAsyncUnary(1, context, request, response, cq, tag);
}

::grpc::RpcService* CmsQuery::Service::service() {
  if (service_ != nullptr) {
    return service_;
  }
  service_ = new ::grpc::RpcService();
  service_->AddMethod(new ::grpc::RpcServiceMethod(
      CmsQuery_method_names[0],
      ::grpc::RpcMethod::NORMAL_RPC,
      new ::grpc::RpcMethodHandler< CmsQuery::Service, ::cms::Uuid, ::cms::Content>(
          std::function< ::grpc::Status(CmsQuery::Service*, ::grpc::ServerContext*, const ::cms::Uuid*, ::cms::Content*)>(&CmsQuery::Service::get), this),
      new ::cms::Uuid, new ::cms::Content));
  service_->AddMethod(new ::grpc::RpcServiceMethod(
      CmsQuery_method_names[1],
      ::grpc::RpcMethod::NORMAL_RPC,
      new ::grpc::RpcMethodHandler< CmsQuery::Service, ::cms::Query, ::cms::ContentList>(
          std::function< ::grpc::Status(CmsQuery::Service*, ::grpc::ServerContext*, const ::cms::Query*, ::cms::ContentList*)>(&CmsQuery::Service::get_all), this),
      new ::cms::Query, new ::cms::ContentList));
  return service_;
}


static const char* ContentCmdHandler_method_names[] = {
  "/cms.ContentCmdHandler/create",
};

std::unique_ptr< ContentCmdHandler::Stub> ContentCmdHandler::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel) {
  std::unique_ptr< ContentCmdHandler::Stub> stub(new ContentCmdHandler::Stub(channel));
  return stub;
}

ContentCmdHandler::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : ::grpc::InternalStub(channel), rpcmethod_create_(ContentCmdHandler_method_names[0], ::grpc::RpcMethod::NORMAL_RPC, channel->RegisterMethod(ContentCmdHandler_method_names[0]))
  {}

::grpc::Status ContentCmdHandler::Stub::create(::grpc::ClientContext* context, const ::cms::Content& request, ::cms::CmdResponse* response) {
  return ::grpc::BlockingUnaryCall(channel(), rpcmethod_create_, context, request, response);
}

std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cms::CmdResponse>> ContentCmdHandler::Stub::Asynccreate(::grpc::ClientContext* context, const ::cms::Content& request, ::grpc::CompletionQueue* cq, void* tag) {
  return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cms::CmdResponse>>(new ::grpc::ClientAsyncResponseReader< ::cms::CmdResponse>(channel(), cq, rpcmethod_create_, context, request, tag));
}

ContentCmdHandler::AsyncService::AsyncService(::grpc::CompletionQueue* cq) : ::grpc::AsynchronousService(cq, ContentCmdHandler_method_names, 1) {}

ContentCmdHandler::Service::~Service() {
  delete service_;
}

::grpc::Status ContentCmdHandler::Service::create(::grpc::ServerContext* context, const ::cms::Content* request, ::cms::CmdResponse* response) {
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED);
}

void ContentCmdHandler::AsyncService::Requestcreate(::grpc::ServerContext* context, ::cms::Content* request, ::grpc::ServerAsyncResponseWriter< ::cms::CmdResponse>* response, ::grpc::CompletionQueue* cq, void* tag) {
  AsynchronousService::RequestAsyncUnary(0, context, request, response, cq, tag);
}

::grpc::RpcService* ContentCmdHandler::Service::service() {
  if (service_ != nullptr) {
    return service_;
  }
  service_ = new ::grpc::RpcService();
  service_->AddMethod(new ::grpc::RpcServiceMethod(
      ContentCmdHandler_method_names[0],
      ::grpc::RpcMethod::NORMAL_RPC,
      new ::grpc::RpcMethodHandler< ContentCmdHandler::Service, ::cms::Content, ::cms::CmdResponse>(
          std::function< ::grpc::Status(ContentCmdHandler::Service*, ::grpc::ServerContext*, const ::cms::Content*, ::cms::CmdResponse*)>(&ContentCmdHandler::Service::create), this),
      new ::cms::Content, new ::cms::CmdResponse));
  return service_;
}


static const char* EventListenerEndpoint_method_names[] = {
  "/cms.EventListenerEndpoint/on",
};

std::unique_ptr< EventListenerEndpoint::Stub> EventListenerEndpoint::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel) {
  std::unique_ptr< EventListenerEndpoint::Stub> stub(new EventListenerEndpoint::Stub(channel));
  return stub;
}

EventListenerEndpoint::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : ::grpc::InternalStub(channel), rpcmethod_on_(EventListenerEndpoint_method_names[0], ::grpc::RpcMethod::NORMAL_RPC, channel->RegisterMethod(EventListenerEndpoint_method_names[0]))
  {}

::grpc::Status EventListenerEndpoint::Stub::on(::grpc::ClientContext* context, const ::cms::Event& request, ::cms::CmdResponse* response) {
  return ::grpc::BlockingUnaryCall(channel(), rpcmethod_on_, context, request, response);
}

std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cms::CmdResponse>> EventListenerEndpoint::Stub::Asyncon(::grpc::ClientContext* context, const ::cms::Event& request, ::grpc::CompletionQueue* cq, void* tag) {
  return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cms::CmdResponse>>(new ::grpc::ClientAsyncResponseReader< ::cms::CmdResponse>(channel(), cq, rpcmethod_on_, context, request, tag));
}

EventListenerEndpoint::AsyncService::AsyncService(::grpc::CompletionQueue* cq) : ::grpc::AsynchronousService(cq, EventListenerEndpoint_method_names, 1) {}

EventListenerEndpoint::Service::~Service() {
  delete service_;
}

::grpc::Status EventListenerEndpoint::Service::on(::grpc::ServerContext* context, const ::cms::Event* request, ::cms::CmdResponse* response) {
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED);
}

void EventListenerEndpoint::AsyncService::Requeston(::grpc::ServerContext* context, ::cms::Event* request, ::grpc::ServerAsyncResponseWriter< ::cms::CmdResponse>* response, ::grpc::CompletionQueue* cq, void* tag) {
  AsynchronousService::RequestAsyncUnary(0, context, request, response, cq, tag);
}

::grpc::RpcService* EventListenerEndpoint::Service::service() {
  if (service_ != nullptr) {
    return service_;
  }
  service_ = new ::grpc::RpcService();
  service_->AddMethod(new ::grpc::RpcServiceMethod(
      EventListenerEndpoint_method_names[0],
      ::grpc::RpcMethod::NORMAL_RPC,
      new ::grpc::RpcMethodHandler< EventListenerEndpoint::Service, ::cms::Event, ::cms::CmdResponse>(
          std::function< ::grpc::Status(EventListenerEndpoint::Service*, ::grpc::ServerContext*, const ::cms::Event*, ::cms::CmdResponse*)>(&EventListenerEndpoint::Service::on), this),
      new ::cms::Event, new ::cms::CmdResponse));
  return service_;
}


static const char* EventSource_method_names[] = {
  "/cms.EventSource/apply",
  "/cms.EventSource/subscribe",
  "/cms.EventSource/unsubscribe",
};

std::unique_ptr< EventSource::Stub> EventSource::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel) {
  std::unique_ptr< EventSource::Stub> stub(new EventSource::Stub(channel));
  return stub;
}

EventSource::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : ::grpc::InternalStub(channel), rpcmethod_apply_(EventSource_method_names[0], ::grpc::RpcMethod::NORMAL_RPC, channel->RegisterMethod(EventSource_method_names[0]))
  , rpcmethod_subscribe_(EventSource_method_names[1], ::grpc::RpcMethod::NORMAL_RPC, channel->RegisterMethod(EventSource_method_names[1]))
  , rpcmethod_unsubscribe_(EventSource_method_names[2], ::grpc::RpcMethod::NORMAL_RPC, channel->RegisterMethod(EventSource_method_names[2]))
  {}

::grpc::Status EventSource::Stub::apply(::grpc::ClientContext* context, const ::cms::Event& request, ::cms::CmdResponse* response) {
  return ::grpc::BlockingUnaryCall(channel(), rpcmethod_apply_, context, request, response);
}

std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cms::CmdResponse>> EventSource::Stub::Asyncapply(::grpc::ClientContext* context, const ::cms::Event& request, ::grpc::CompletionQueue* cq, void* tag) {
  return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cms::CmdResponse>>(new ::grpc::ClientAsyncResponseReader< ::cms::CmdResponse>(channel(), cq, rpcmethod_apply_, context, request, tag));
}

::grpc::Status EventSource::Stub::subscribe(::grpc::ClientContext* context, const ::cms::EventListener& request, ::cms::CmdResponse* response) {
  return ::grpc::BlockingUnaryCall(channel(), rpcmethod_subscribe_, context, request, response);
}

std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cms::CmdResponse>> EventSource::Stub::Asyncsubscribe(::grpc::ClientContext* context, const ::cms::EventListener& request, ::grpc::CompletionQueue* cq, void* tag) {
  return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cms::CmdResponse>>(new ::grpc::ClientAsyncResponseReader< ::cms::CmdResponse>(channel(), cq, rpcmethod_subscribe_, context, request, tag));
}

::grpc::Status EventSource::Stub::unsubscribe(::grpc::ClientContext* context, const ::cms::EventListener& request, ::cms::CmdResponse* response) {
  return ::grpc::BlockingUnaryCall(channel(), rpcmethod_unsubscribe_, context, request, response);
}

std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cms::CmdResponse>> EventSource::Stub::Asyncunsubscribe(::grpc::ClientContext* context, const ::cms::EventListener& request, ::grpc::CompletionQueue* cq, void* tag) {
  return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cms::CmdResponse>>(new ::grpc::ClientAsyncResponseReader< ::cms::CmdResponse>(channel(), cq, rpcmethod_unsubscribe_, context, request, tag));
}

EventSource::AsyncService::AsyncService(::grpc::CompletionQueue* cq) : ::grpc::AsynchronousService(cq, EventSource_method_names, 3) {}

EventSource::Service::~Service() {
  delete service_;
}

::grpc::Status EventSource::Service::apply(::grpc::ServerContext* context, const ::cms::Event* request, ::cms::CmdResponse* response) {
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED);
}

void EventSource::AsyncService::Requestapply(::grpc::ServerContext* context, ::cms::Event* request, ::grpc::ServerAsyncResponseWriter< ::cms::CmdResponse>* response, ::grpc::CompletionQueue* cq, void* tag) {
  AsynchronousService::RequestAsyncUnary(0, context, request, response, cq, tag);
}

::grpc::Status EventSource::Service::subscribe(::grpc::ServerContext* context, const ::cms::EventListener* request, ::cms::CmdResponse* response) {
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED);
}

void EventSource::AsyncService::Requestsubscribe(::grpc::ServerContext* context, ::cms::EventListener* request, ::grpc::ServerAsyncResponseWriter< ::cms::CmdResponse>* response, ::grpc::CompletionQueue* cq, void* tag) {
  AsynchronousService::RequestAsyncUnary(1, context, request, response, cq, tag);
}

::grpc::Status EventSource::Service::unsubscribe(::grpc::ServerContext* context, const ::cms::EventListener* request, ::cms::CmdResponse* response) {
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED);
}

void EventSource::AsyncService::Requestunsubscribe(::grpc::ServerContext* context, ::cms::EventListener* request, ::grpc::ServerAsyncResponseWriter< ::cms::CmdResponse>* response, ::grpc::CompletionQueue* cq, void* tag) {
  AsynchronousService::RequestAsyncUnary(2, context, request, response, cq, tag);
}

::grpc::RpcService* EventSource::Service::service() {
  if (service_ != nullptr) {
    return service_;
  }
  service_ = new ::grpc::RpcService();
  service_->AddMethod(new ::grpc::RpcServiceMethod(
      EventSource_method_names[0],
      ::grpc::RpcMethod::NORMAL_RPC,
      new ::grpc::RpcMethodHandler< EventSource::Service, ::cms::Event, ::cms::CmdResponse>(
          std::function< ::grpc::Status(EventSource::Service*, ::grpc::ServerContext*, const ::cms::Event*, ::cms::CmdResponse*)>(&EventSource::Service::apply), this),
      new ::cms::Event, new ::cms::CmdResponse));
  service_->AddMethod(new ::grpc::RpcServiceMethod(
      EventSource_method_names[1],
      ::grpc::RpcMethod::NORMAL_RPC,
      new ::grpc::RpcMethodHandler< EventSource::Service, ::cms::EventListener, ::cms::CmdResponse>(
          std::function< ::grpc::Status(EventSource::Service*, ::grpc::ServerContext*, const ::cms::EventListener*, ::cms::CmdResponse*)>(&EventSource::Service::subscribe), this),
      new ::cms::EventListener, new ::cms::CmdResponse));
  service_->AddMethod(new ::grpc::RpcServiceMethod(
      EventSource_method_names[2],
      ::grpc::RpcMethod::NORMAL_RPC,
      new ::grpc::RpcMethodHandler< EventSource::Service, ::cms::EventListener, ::cms::CmdResponse>(
          std::function< ::grpc::Status(EventSource::Service*, ::grpc::ServerContext*, const ::cms::EventListener*, ::cms::CmdResponse*)>(&EventSource::Service::unsubscribe), this),
      new ::cms::EventListener, new ::cms::CmdResponse));
  return service_;
}


static const char* AggregateRepository_method_names[] = {
  "/cms.AggregateRepository/get",
  "/cms.AggregateRepository/set",
};

std::unique_ptr< AggregateRepository::Stub> AggregateRepository::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel) {
  std::unique_ptr< AggregateRepository::Stub> stub(new AggregateRepository::Stub(channel));
  return stub;
}

AggregateRepository::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : ::grpc::InternalStub(channel), rpcmethod_get_(AggregateRepository_method_names[0], ::grpc::RpcMethod::NORMAL_RPC, channel->RegisterMethod(AggregateRepository_method_names[0]))
  , rpcmethod_set_(AggregateRepository_method_names[1], ::grpc::RpcMethod::NORMAL_RPC, channel->RegisterMethod(AggregateRepository_method_names[1]))
  {}

::grpc::Status AggregateRepository::Stub::get(::grpc::ClientContext* context, const ::cms::Uuid& request, ::cms::Aggregate* response) {
  return ::grpc::BlockingUnaryCall(channel(), rpcmethod_get_, context, request, response);
}

std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cms::Aggregate>> AggregateRepository::Stub::Asyncget(::grpc::ClientContext* context, const ::cms::Uuid& request, ::grpc::CompletionQueue* cq, void* tag) {
  return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cms::Aggregate>>(new ::grpc::ClientAsyncResponseReader< ::cms::Aggregate>(channel(), cq, rpcmethod_get_, context, request, tag));
}

::grpc::Status AggregateRepository::Stub::set(::grpc::ClientContext* context, const ::cms::Aggregate& request, ::cms::CmdResponse* response) {
  return ::grpc::BlockingUnaryCall(channel(), rpcmethod_set_, context, request, response);
}

std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cms::CmdResponse>> AggregateRepository::Stub::Asyncset(::grpc::ClientContext* context, const ::cms::Aggregate& request, ::grpc::CompletionQueue* cq, void* tag) {
  return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::cms::CmdResponse>>(new ::grpc::ClientAsyncResponseReader< ::cms::CmdResponse>(channel(), cq, rpcmethod_set_, context, request, tag));
}

AggregateRepository::AsyncService::AsyncService(::grpc::CompletionQueue* cq) : ::grpc::AsynchronousService(cq, AggregateRepository_method_names, 2) {}

AggregateRepository::Service::~Service() {
  delete service_;
}

::grpc::Status AggregateRepository::Service::get(::grpc::ServerContext* context, const ::cms::Uuid* request, ::cms::Aggregate* response) {
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED);
}

void AggregateRepository::AsyncService::Requestget(::grpc::ServerContext* context, ::cms::Uuid* request, ::grpc::ServerAsyncResponseWriter< ::cms::Aggregate>* response, ::grpc::CompletionQueue* cq, void* tag) {
  AsynchronousService::RequestAsyncUnary(0, context, request, response, cq, tag);
}

::grpc::Status AggregateRepository::Service::set(::grpc::ServerContext* context, const ::cms::Aggregate* request, ::cms::CmdResponse* response) {
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED);
}

void AggregateRepository::AsyncService::Requestset(::grpc::ServerContext* context, ::cms::Aggregate* request, ::grpc::ServerAsyncResponseWriter< ::cms::CmdResponse>* response, ::grpc::CompletionQueue* cq, void* tag) {
  AsynchronousService::RequestAsyncUnary(1, context, request, response, cq, tag);
}

::grpc::RpcService* AggregateRepository::Service::service() {
  if (service_ != nullptr) {
    return service_;
  }
  service_ = new ::grpc::RpcService();
  service_->AddMethod(new ::grpc::RpcServiceMethod(
      AggregateRepository_method_names[0],
      ::grpc::RpcMethod::NORMAL_RPC,
      new ::grpc::RpcMethodHandler< AggregateRepository::Service, ::cms::Uuid, ::cms::Aggregate>(
          std::function< ::grpc::Status(AggregateRepository::Service*, ::grpc::ServerContext*, const ::cms::Uuid*, ::cms::Aggregate*)>(&AggregateRepository::Service::get), this),
      new ::cms::Uuid, new ::cms::Aggregate));
  service_->AddMethod(new ::grpc::RpcServiceMethod(
      AggregateRepository_method_names[1],
      ::grpc::RpcMethod::NORMAL_RPC,
      new ::grpc::RpcMethodHandler< AggregateRepository::Service, ::cms::Aggregate, ::cms::CmdResponse>(
          std::function< ::grpc::Status(AggregateRepository::Service*, ::grpc::ServerContext*, const ::cms::Aggregate*, ::cms::CmdResponse*)>(&AggregateRepository::Service::set), this),
      new ::cms::Aggregate, new ::cms::CmdResponse));
  return service_;
}


}  // namespace cms

